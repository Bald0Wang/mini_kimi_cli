# 04. 创造：赋予新能力 (Hands-on Labs)

> "纸上得来终觉浅，绝知此事要躬行。" —— 陆游

理论已经学得够多了，现在是时候弄脏双手（Get your hands dirty）了。在这个阶段，你将不再是旁观者，而是 Mini Kimi 的创造者。我们将通过几个精心设计的小实验，尝试修改它的核心设定，甚至赋予它全新的计算能力。这种“修改-运行-反馈”的循环，是程序员最快乐的时刻。

### 知识加油站 ⛽️

#### 1. 提示词工程 (Prompt Engineering)
你将会在 Lab 1 中体验到，仅仅改变几行自然语言（System Prompt），就能彻底改变 Agent 的性格和行为。这就是提示词工程的魔力。它不仅仅是“说话”，而是一种用自然语言进行编程的新范式。
*   **核心技巧**: 角色扮演 (Role Prompting), 少样本提示 (Few-Shot Prompting), 思维链 (CoT).
*   **参考来源**: [OpenAI Prompt Engineering Guide](https://platform.openai.com/docs/guides/prompt-engineering)

#### 2. 接口契约 (Interface Contract)
在 Lab 2 中添加新工具时，你会发现，只要你的工具遵守了特定的“契约”（即 `schema` 定义和 `__call__` 方法），它就能被系统无缝集成。这就是面向接口编程的威力。

---

### 学习目标

- 通过“改一点点代码”，验证你已经理解 ReAct + 工具调用
- 学会给工具加最小的安全约束/输出约束
- 形成“改动 → 运行 → 验证 → 复盘”的工程习惯

---

### Lab 1：改 System Prompt（最简单、收益最大）

**改动位置**

- `mini_kimi/src/mini_kimi/soul/soul.py`
- `Soul.__init__` 里 `self.messages[0]["content"]` 的内容

**任务**

- 增加一条规则：回答必须用中文，并且尽量分点

**验证**

- 重启程序
- 输入：`介绍一下 ReAct`
- 预期：回答用中文并分点

**观测信号**

- 你应该看到模型回答的语言风格发生稳定变化
- 如果没有变化，通常是：没重启进程 / 改错位置 / prompt 被覆盖

---

### Lab 2：添加一个计算器工具（体验“新增工具→注册→被调用”）

**任务目标**

- 新增 `AddTool`：接收 `x`、`y` 两个数字，返回它们的和

**建议文件结构（按现有项目分层）**

- 新建：`mini_kimi/src/mini_kimi/tools/calc/add_tool.py`
- 并在 `mini_kimi/src/mini_kimi/tools/calc/__init__.py` 添加包声明（可选）
- 在 `mini_kimi/src/mini_kimi/soul/soul.py` 注册工具

**最小代码骨架（示例）**

新建：`mini_kimi/src/mini_kimi/tools/calc/add_tool.py`

```python
class AddTool:
    name = "Add"

    schema = {
        "type": "function",
        "function": {
            "name": "Add",
            "description": "Add two numbers and return the sum.",
            "parameters": {
                "type": "object",
                "properties": {
                    "x": {"type": "number", "description": "First number"},
                    "y": {"type": "number", "description": "Second number"}
                },
                "required": ["x", "y"]
            }
        }
    }

    def __call__(self, x: float, y: float) -> str:
        return str(x + y)
```

然后在 `mini_kimi/src/mini_kimi/soul/soul.py` 里注册：

- 在 imports 里引入 `AddTool`
- 在 `self.tools = [...]` 里追加 `AddTool()`
- 在工具执行分支里增加 `elif func_name == "Add": ...`

**验证**

- 输入：`用工具计算 12345 + 67890`
- 预期：终端出现 `Add`（或你定义的工具名）工具调用，并返回正确结果

**常见坑**

- schema 里 `function.name` 和 `tool_map` 的 key 不一致 → “Tool not found”
- `function.arguments` 不是合法 JSON → `json.loads` 失败

---

### Lab 3：限制 WriteFile 的写入范围（最小安全实践）

**问题背景**

当前 `WriteFileTool` 只做了简单的 `..` 检测，但仍可能写到任意路径。

**任务**

- 约束只能写到项目目录下的 `mini_kimi/out/` 目录（没有则自动创建）

**改动位置**

- `mini_kimi/src/mini_kimi/tools/file/write_tool.py`

**验证**

1) 输入：`把“ok”写入 out/a.txt`
2) 输入：`把“hack”写入 C:\\Windows\\Temp\\x.txt`

**预期**

- 第 1 条成功
- 第 2 条被拒绝并返回可读的错误提示

**技术要点**

- 工具安全的第一步是“限定边界”：限定目录、限定扩展名、限定最大长度
- 不要只做字符串判断（例如仅禁止 `..`），更推荐“拼接后再归一化路径”再判断是否越界（进阶）

---

### Lab 4（可选）：给 Web 深度限制做“硬限制”

**说明**

现在的“最多 3 层”是靠 prompt 约束，新手可以尝试做工程化的硬限制。

**一个可行方向**

- 在 `Soul` 中维护一个计数器：`web_depth`
- 约定：
  - 每次 `SearchWeb` 把深度重置为 0
  - 每次 `FetchURL` 深度 +1
  - 深度 > 3 时拒绝执行并返回提示

**验证**

- 连续让模型抓取多次链接，观察是否在第 4 次开始被拒绝

---

### 本节小结

- **你完成了什么**：从“改 prompt”到“新增工具”再到“加安全边界”
- **你得到的工程习惯**：每个改动都要有“验证任务”和“预期现象”
